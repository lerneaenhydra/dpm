function consts = param_setup(opmode, res)
%PARAM_SETUP(opmode) Returns a structure with all constant system
%parameters over time, with different parameters depending on the operation
%mode
%	opmode The operation mode to configure for. Allowable values are;
%		'1D' - Will generate parameters used for the one-dimensional
%		optimization problem where the global SOC trajectory is solved
%		'2D' - Will generate parameters used for the two-dimensional
%		optimization problem where crankshaft are modeled
%
%	res		Required parameter for the 2-dimensional case, must be equal to
%	res{end} as returned by the DPM solver from the 1-dimensional case.
%
%	Use two optimization passes to allow for greatly reducing the search
%	space in the 2-D case, making it a feasible problem to solve. The SOC
%	trajectory from the 1-D case is used 

opmode_1d = '1D';
opmode_2d = '2D';

if(~strcmp(opmode, opmode_1d) && ~strcmp(opmode, opmode_2d))
	error('param_setup:Invalid operation mode specified!');
end

consts.T_f = 600;							%Total simulation time [s]

%Sample time and total time vector for 1D case
T_s_1D = 1;	%Use a short sample period for the 1-D case to allow for a narrower SOC band when performing the 2-D pass
tt_1D = 0:T_s_1D:consts.T_f;

if(strcmp(opmode, opmode_1d))
	consts.T_s = T_s_1D;					%System input period for sampled-time basis functions [s]
	consts.tt = tt_1D;						%Vector with time at all sample points
else
	consts.T_s = 0.5;						%System input period for sampled-time basis functions [s]
	consts.tt = 0:consts.T_s:consts.T_f;	%Vector with time at all sample points
end

%Model physical parameters

consts.ice_maxtau = 100;
consts.shaft_maxw = rpm2rads(4e3);
consts.shaft_i = 0.5;					%ICE/generator crankshaft moment of inertia [kg*m^2]
consts.gen_maxtau = 100;				%Maximum generator torque [Nm]
consts.gen_quadloss = 1e-1;				%Generator quadratic loss term [W/Nm^2] (EG. if 1e-1 power loss will be 1kW if net torque is 100Nm)
consts.shaft_fric = 10;					%Shaft/engine/generator friction torque [Nm]
consts.ice_fuelinst_opt_n = 1e3;		%Number of interpolation points in power for optimal ICE operating point solution (used in the one-dimensional solution)

%Demanded power trajectory
if(strcmp(opmode, opmode_1d))
	%For the 1D-case, let the instantaneous power be the moving average of
	%the sample period
	consts.tot_p_f = @(t_in) arrayfun(@(t) mean(calc_power_cycle(linspace(t-T_s_1D/2, t+T_s_1D/2, 100))), t_in);
else
	consts.tot_p_f = @calc_power_cycle;
end
consts.tot_p_max = max(abs(consts.tot_p_f(consts.tt)));

consts.batt_quadloss = 1e-6;				%Quadratic battery loss term [W/W^2] (EG. if 1e-6 power loss will be 10kW if net battery power is 100kW)
%The total battery energy. To determine the minimum value perform a 1-D
%simulation with a large value and check the total SOC swing.
consts.batt_energy = 3.5e6;			%Set total battery energy for one-dimensional solution [J]

%Speed at which to start linearly decreasing friction term. Chosen value
%ensures that if generator/ICE delivers net zero torque the angular speed
%will never become negative. Scale by term 1+eps to ensure that numerical
%issues don't bring the angular speed to some small negative value
consts.shaft_fric_norm_w = (1 + eps(1)) * consts.shaft_fric * consts.T_s / consts.shaft_i;

%Dynamic programminmg set-up

p_max = consts.ice_maxtau * consts.shaft_maxw - consts.tot_p_max;
%Maximum change in battery energy per time sample
consts.soc_e_delta = p_max / (1 + p_max * consts.batt_quadloss) * consts.T_s;

if(strcmp(opmode, opmode_1d))	
	%Require a dense enough SOC grid so that reachability is ensured. This
	%is guaranteed by setting the grid density so that the maximum
	%commanded power results in moving to more than the next state grid
	%point regardless of the power commanded by the drive cycle
	consts.N_grid_soc = ceil(1.1 * consts.batt_energy/consts.soc_e_delta);			%Number of grid points for state-of-charge variable
	consts.N_grid_soc = max(consts.N_grid_soc, 250);									%Optionally require a minimum grid density

	consts.N_grid_P_i_c_e = 25;				%Number of grid points for ICE power levels
else
	quantization.tau = 2.5;					%Torque quantization used for ICE and generator [Nm]
	
	%Number of grid points for angular velocity variable
	consts.N_grid_w = ceil(1.1 * (consts.gen_maxtau + consts.ice_maxtau) * consts.T_s / (consts.shaft_i * consts.shaft_maxw));
	consts.N_grid_w = max(consts.N_grid_w, 25);
	consts.N_int = 20;						%Number of integration points for BSFC/fuel consumption calculation
end

%Print information on the resolution generated by the chosen grid density
if(strcmp(opmode, opmode_2d))
	consts.N_grid_tau_i_c_e = consts.ice_maxtau/quantization.tau + 1;			%Number of grid points for ICE torque
	consts.N_grid_tau_g_e_n = 2*consts.gen_maxtau/quantization.tau + 1;			%Number of grid points for generator torque

	if(round(consts.N_grid_tau_i_c_e) ~= consts.N_grid_tau_i_c_e | ...
		round(consts.N_grid_tau_g_e_n) ~= consts.N_grid_tau_g_e_n)
		error('Selected torque quantization not acheivable with torque limits for ICE and generator');
	end
end

if(strcmp(opmode, opmode_1d))
	%Model simulation set-up
	consts.statenames = {'soc'};		%Name (and order) of state variables in sysmod funcion
	consts.initconds_low = 0;			%Lower bound for initial conditions in same order as inps.statenames
	consts.initconds_high = 0.5;		%Upper bound for initial conditions in same order as inps.statenames
	consts.finalconds_low = 0.5;		%Lower final conditions for state variables in same order as inps.statenames
	consts.finalconds_high = 1;			%Upper final conditions for state variables in same order as inps.statenames
	consts.ctrlnames = {'P_i_c_e'};		%Name (and order) of model control variables
else
	%Model simulation set-up
	consts.statenames = {'w'; 'soc'};		%Name (and order) of state variables in sysmod funcion
	consts.initconds_low = [0; 0];			%Lower bound for initial conditions in same order as inps.statenames
	init_w_high = 1.5 * consts.shaft_maxw / consts.N_grid_w;
	consts.initconds_high = [init_w_high ; 0.5];		%Upper bound for initial conditions in same order as inps.statenames
	consts.finalconds_low = [0; 0.5];		%Lower final conditions for state variables in same order as inps.statenames
	consts.finalconds_high = [consts.shaft_maxw; 1];		%Upper final conditions for state variables in same order as inps.statenames
	consts.ctrlnames = {'tau_i_c_e'; 'tau_g_e_n'};			%Name (and order) of model control variables
end

%Remaining dynamic-programming environment set-up

consts.dp_inp = dpm();

if(strcmp(opmode, opmode_1d))
	%The number of state variables
	consts.dp_inp.prb.N_x = 1;
	%The number of control variables
	consts.dp_inp.prb.N_u = 1;
	%Contains the number of time-steps to simulate
	consts.dp_inp.prb.N_t = round(consts.T_f / consts.T_s + 1);
	%Contains the sample period
	consts.dp_inp.prb.T_s = consts.T_s;
else
	%The number of state variables
	consts.dp_inp.prb.N_x = 2;
	%The number of control variables
	consts.dp_inp.prb.N_u = 2;
	%Contains the number of time-steps to simulate
	consts.dp_inp.prb.N_t = round(consts.T_f / consts.T_s + 1);
	%Contains the sample period
	consts.dp_inp.prb.T_s = consts.T_s;
end

if(strcmp(opmode, opmode_1d))
	%Contains the lower bound for all state variables
	consts.dp_inp.prb.X_l = 0;
	%Contains the upper bound for all state variables
	consts.dp_inp.prb.X_h = 1;
	
	%Contains the lower bound for the terminal condition for states
	consts.dp_inp.prb.XT_l = consts.finalconds_low;
	%Contains the upper bound for the terminal condition for states
	consts.dp_inp.prb.XT_h = consts.finalconds_high;

	%Contains the lower bound for the initial condition for states
	consts.dp_inp.prb.X0_l = consts.initconds_low;
	%Contains the upper bound for the initial condition for states
	consts.dp_inp.prb.X0_h = consts.initconds_high;

	%Contains the lower bound for all inputs
	consts.dp_inp.prb.U_l = 0;
	%Contains the upper bound for all inputs
	consts.dp_inp.prb.U_h = consts.ice_maxtau * consts.shaft_maxw;

	%Contains the number of grid points for each state variable
	consts.dp_inp.prb.N_x_grid = consts.N_grid_soc;
	%Contains the number of grid points for each control signal
	consts.dp_inp.prb.N_u_grid = consts.N_grid_P_i_c_e;
else
	%Contains the lower bound for all state variables
	%Add regularization term that allows, but heavily penalizes, negative
	%shaft velocities. Set up limit to ensure w == 0 is included as a grid
	%point
	consts.dp_inp.prb.X_l = [-consts.shaft_maxw/(consts.N_grid_w - 2); 0];
	%Contains the upper bound for all state variables
	consts.dp_inp.prb.X_h = [consts.shaft_maxw; 1];
	
	%Contains the lower bound for the terminal condition for states
	consts.dp_inp.prb.XT_l = consts.finalconds_low;
	%Contains the upper bound for the terminal condition for states
	consts.dp_inp.prb.XT_h = consts.finalconds_high;

	%Contains the lower bound for the initial condition for states
	consts.dp_inp.prb.X0_l = consts.initconds_low;
	%Contains the upper bound for the initial condition for states
	consts.dp_inp.prb.X0_h = consts.initconds_high;

	%Contains the lower bound for all inputs
	consts.dp_inp.prb.U_l = [0; -consts.gen_maxtau];
	%Contains the upper bound for all inputs
	consts.dp_inp.prb.U_h = [consts.ice_maxtau; consts.gen_maxtau];
	
	%The sample points (in time) that will be used to generate the non-uniform
	%grid, if we have results to base the limited search on
	grid_subset.t = tt_1D;
	
	max_shaft_energy = 1/2 * consts.shaft_i * consts.shaft_maxw^2;	%Maximum kinetic energy in shaft
	multidim_range = 2.5 * max_shaft_energy / consts.batt_energy * ones(size(tt_1D));	%Set the search range to be sufficiently larger than the maximum energy in the crankshaft
	multidim_N_soc = 10;
	
	if(exist('res', 'var'))
		%Center-points for grid generation for each time in grid_subset.t
		grid_subset.center = [res.x];
		%Grid extent for grid generation for each time in grid_subset.t
		grid_subset.range = multidim_range;
		consts.N_grid_soc = multidim_N_soc;
	else
		grid_subset.center = 0.5 * ones(size(tt_1D));
		grid_subset.range = 1 * ones(size(tt_1D));
		consts.N_grid_soc = ceil(multidim_N_soc/multidim_range(1));
	end
	
	%Contains the number of grid points for each state variable
	consts.dp_inp.prb.N_x_grid = [consts.N_grid_w; consts.N_grid_soc];
	%Contains the number of grid points for each control signal
	consts.dp_inp.prb.N_u_grid = [consts.N_grid_tau_i_c_e; consts.N_grid_tau_g_e_n];
	
	
	%Interpolation method used for grid generation between samples in
	%grid_subset.t. May be any value that is accepted by the interp1 function.
	grid_subset.interpmode = 'linear';
	
	consts.dp_inp.prb.grid_seed{2} = grid_subset;
end

consts.dp_inp.sol.debug = false;
consts.dp_inp.sol.pen_norm = 'squaredeuclidean';
consts.dp_inp.sol.pen_thrs = 3.^2;
consts.dp_inp.sol.pen_fun_s = @(x) 1;
consts.dp_inp.sol.pen_fun_a = @(x) calc_fuelinst(consts.shaft_maxw, consts.ice_maxtau) * consts.T_s;

if(strcmp(opmode, opmode_1d))
	%The amount to scale the grid extent in each iteration when decreasing the
	%grid size, centered about the previous optimal path
	consts.dp_inp.sol.mu_grid_dec = 0.8;
	%The amount to scale the grid extent in each iteration when increasing the
	%grid size, centered about the previous optimal path. Should generally be
	%significantly smaller than 2 - mu_grid_dec. A good first guess could be
	%1+(1-mu_grid_dec)/10.
	consts.dp_inp.sol.mu_grid_inc = 1.01;
	%Set to true to allow re-gridding the state variables after each iteration
	consts.dp_inp.sol.regrid_x = true;
	%Set to true to allow re-gridding the control variables after each
	%iteration
	consts.dp_inp.sol.regrid_u = true;
	%Total number of solution iterations
	consts.dp_inp.sol.iter_max = 10;
	%System configuration
	consts.dp_inp.sol.fun = @dp_sysmod_1d;		%Set to handle to system model
	consts.dp_inp.sol.plotfun = @plot_iter;	%If set to handle to iteration plot will display on every iteration
	consts.dp_inp.sol.interpmode = 'linear';
	consts.dp_inp.sol.extrapmode = inf;
else
	%The amount to scale the grid extent in each iteration when decreasing the
	%grid size, centered about the previous optimal path
	consts.dp_inp.sol.mu_grid_dec = 0.8;
	%The amount to scale the grid extent in each iteration when increasing the
	%grid size, centered about the previous optimal path. Should generally be
	%significantly smaller than 2 - mu_grid_dec. A good first guess could be
	%1+(1-mu_grid_dec)/10.
	consts.dp_inp.sol.mu_grid_inc = 1.01;
	%Set to true to allow re-gridding the state variables after each iteration
	consts.dp_inp.sol.regrid_x = true;
	%Set to true to allow re-gridding the control variables after each
	%iteration
	consts.dp_inp.sol.regrid_u = true;
	%Total number of solution iterations
	if(exist('res', 'var'))
		consts.dp_inp.sol.iter_max = 15;	%Perform more iterations for multipass mode to look at convergence properties
	else
		consts.dp_inp.sol.iter_max = 5;
	end
	%System configuration
	consts.dp_inp.sol.fun = @dp_sysmod_2d;		%Set to handle to system model
	consts.dp_inp.sol.plotfun = @plot_iter;	%If set to handle to iteration plot will display on every iteration
	consts.dp_inp.sol.interpmode = 'linear';
	consts.dp_inp.sol.extrapmode = 'nearest';
end

if(strcmp(opmode, opmode_2d))
	%Print some information on the quantization effects for the coarsest and
	%finest meshes that will be used
	quantization.tau_i_c_e = consts.ice_maxtau / (consts.N_grid_tau_i_c_e - 1);
	quantization.tau_g_e_n = 2 * consts.gen_maxtau / (consts.N_grid_tau_g_e_n - 1);
	quantization.w = consts.shaft_maxw / consts.N_grid_w;
	quantization.soc = 1 / consts.N_grid_soc * multidim_range(1);
	fprintf(['Variable quantization with coarsest mesh;\n' ...
		'\t tau_ice %g Nm\n' ...
		'\t tau_gen %g Nm\n' ...
		'\t shaft speed %g rad/s\n' ...
		'\t battery SOC %g\n'], ...
		quantization.tau_i_c_e, ...
		quantization.tau_g_e_n, ...
		quantization.w, ...
		quantization.soc);

	if consts.dp_inp.sol.regrid_x && consts.dp_inp.sol.iter_max > 1
		refinement_x = consts.dp_inp.sol.mu_grid_dec ^ consts.dp_inp.sol.iter_max;
	else
		refinement_x = 1;
	end

	if consts.dp_inp.sol.regrid_u && consts.dp_inp.sol.iter_max > 1
		refinement_u = consts.dp_inp.sol.mu_grid_dec ^ consts.dp_inp.sol.iter_max;
	else
		refinement_u = 1;
	end

	quantization.tau_i_c_e = quantization.tau_i_c_e * refinement_u;
	quantization.tau_g_e_n = quantization.tau_g_e_n * refinement_u;
	quantization.w = quantization.w * refinement_x;
	quantization.soc = quantization.soc * refinement_x;

	fprintf(['Variable quantization with finest mesh (after %d iteration(s));\n' ...
		'\t tau_ice %g Nm\n' ...
		'\t tau_gen %g Nm\n' ...
		'\t shaft speed %g rad/s\n' ...
		'\t battery SOC %g\n'], ...
		consts.dp_inp.sol.iter_max , ...
		quantization.tau_i_c_e, ...
		quantization.tau_g_e_n, ...
		quantization.w, ...
		quantization.soc);
end