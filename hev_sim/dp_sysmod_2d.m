function [x_nn, c] = dp_sysmod_2d(x_n, u_n, t, consts)
	% [x_nn, c] = DP_SYSMOD_2D(x_n, u_n, t, inp) Calculates the state
	% resulting from applying an input u_n to the two-dimensional system
	% while at state x_n.
	%	x_n		State at time t_n. Array where columns correspond to state
	%			variables. Each row corresponds to a given state configuration.
	%	u_n		Control input at time t_n. Array where columns correspond to
	%			control variables. Each row corresponds to a given control 
	%			configuration.
	%	t		The current time
	%	inp		Optional input data.
	%	x_nn	State values at time t_{n+1} given the state x_n at time t_n
	%			and the control u_n. Apply calculations on a row-by-row basis.
	%			(IE. each row in x_n and u_n should uniquely determine each row
	%			in x_nn). Should be of size size(x_n).
	%	c		The cost required to move from a given row in x_n to the same
	%			row in x_nn. Set to inf if state and control results in an
	%			invalid/undefined system transition.
    
	%Convert state variables and inputs to human-readable labels
	
	%Optionally offload model calculation to GPU
	%Comment/uncomment init/exit functions accordingly
	
	%init = @gpuArray;	%Set up for GPU calculation
	init = @(x) x;		%Set up for CPU calculation
	%exit = @gather;	%Set up for GPU calculation
	exit = @(x) x;		%Set up for CPU calculation
	
	st_w = init(x_n(:,1));
	st_soc = init(x_n(:,2));
	tau_ice = init(u_n(:,1));
	tau_gen = init(u_n(:,2));
	shaft_i = init(consts.shaft_i);
	shaft_fric = init(consts.shaft_fric);
	shaft_fric_norm_w = init(consts.shaft_fric_norm_w);
	T_s = init(consts.T_s);
	tot_p = init(consts.tot_p_f(t));
	batt_quadloss = init(consts.batt_quadloss);
	gen_quadloss = init(consts.gen_quadloss);
	batt_energy = init(consts.batt_energy);
	t = init(t);
	N_int = init(consts.N_int);
	t_samp = init((0:consts.N_int-1) * T_s/N_int + 1/2 * T_s/N_int);
	
	%Calculate the exact solution to the model dynamics
	
	%As the shaft speed is essentially modeled as dw/dt = c this simply
	%gives w_n+1 = w_n + T_s * c.
	
	%Determine the shaft speed derivative
	dwdt = 1/shaft_i * calc_tau_net(tau_ice, tau_gen, st_w, shaft_fric, shaft_fric_norm_w);
	
	%Calculate the shaft speed at the next sample
	st_nn_w = st_w + T_s * dwdt;
	
	%The change in SOC is somewhat more complex to solve. The following
	%anonymous function was generated by the 'gen_battmodel.m' function.
	%Function generated by gen_battmodel.m. DO NOT MODIFY HERE!
	%#!KEYSTR_BATTMODEL_c202543ea4a23969c864d7692a381a3d
delta_soc_f = @(w_0,dwdt,t,tau_gen,p_tot,k_lb,k_lg,batt_energy)-(t.*(p_tot+tau_gen.*w_0+k_lg.*tau_gen.^2+k_lb.*(p_tot+tau_gen.*w_0+k_lg.*tau_gen.^2).^2))./batt_energy-(t.^2.*(dwdt.*tau_gen+dwdt.*k_lb.*tau_gen.*(p_tot+tau_gen.*w_0+k_lg.*tau_gen.^2).*2.0).*(1.0./2.0))./batt_energy-(dwdt.^2.*k_lb.*t.^3.*tau_gen.^2.*(1.0./3.0))./batt_energy;

	%Determine the change in SOC
	delta_soc = delta_soc_f(st_w, dwdt, T_s, tau_gen, tot_p, batt_quadloss, gen_quadloss, batt_energy);
	
	%Update the SOC at the next sample
	st_nn_soc = st_soc + delta_soc;

	%Calculate the cost of the state/control combination.
	
	%As the shaft is a pure integrator, we know that the instantaneous
	%shaft speed is st.w + t*dwdt, where t=0 at the start of the sample and
	%t=T_s at the end of the sample. This can then be used to determine the
	%total fuel consumption by integrating fuelinst(st.w + t*dwdt, tau)
	%from t = 0 to t = T_s. This integration is approximated by evaluating
	%the instantaneous fuel consumption at N_int points between t = 0 and t
	% = T_s.
	%At this point, the cost is actually the mass of the fuel
	%consumed per sample.
	
	%Function generated by gen_bsfc_funs.m. Do not modify here!
	%#!KEYSTR_FUELINST_fa8cce87b9df91aa087e5da136558638
fuelinst_f = @(tau,w)abs(tau.*w).*(sqrt(abs(tau-5.0e1).^2.*3.741444191567112e32+abs(w-1.2e2).^2.*5.986310706507379e31).*2.584939414228211e-26+5.555555555555555e-8);
	
	dummy_t = @(t) fuelinst_f(tau_ice, st_w + t .* dwdt);
	
	c = T_s/N_int * dummy_t(t_samp);
	c = sum(c,2);
	
	%x_nn = [st_nn.w, st_nn.soc];
	x_nn = exit([st_nn_w, st_nn_soc]);
	c = exit(c);
	
	%Perform conditional operations on CPU
	
	%Add a penalty term that penalizes nonzero control signals. Set the
	%penalty to be so small as to have absolutely no effect on costs where
	%actual fuel is consumed. Add the penalty term if any control is
	%nonzero.
	nonzero_idx = (tau_ice ~= 0) & (tau_gen ~= 0);
	c(nonzero_idx) = c(nonzero_idx) + realmin;
	
	%Add a finite, but extremely large, penalty if the shaft speed is
	%negative
	c(st_w < 0) = c(st_w < 0) + consts.dp_inp.sol.pen_fun_a(0);
	
	c(~isfinite(c)) = inf;
	
end
