function [x_nn, c] = dp_sysmod_2d(x_n, u_n, t, consts)
	% [x_nn, c] = DP_SYSMOD_2D(x_n, u_n, t, inp) Calculates the state
	% resulting from applying an input u_n to the two-dimensional system
	% while at state x_n.
	%	x_n		State at time t_n. Array where columns correspond to state
	%			variables. Each row corresponds to a given state configuration.
	%	u_n		Control input at time t_n. Array where columns correspond to
	%			control variables. Each row corresponds to a given control 
	%			configuration.
	%	t		The current time
	%	inp		Optional input data.
	%	x_nn	State values at time t_{n+1} given the state x_n at time t_n
	%			and the control u_n. Apply calculations on a row-by-row basis.
	%			(IE. each row in x_n and u_n should uniquely determine each row
	%			in x_nn). Should be of size size(x_n).
	%	c		The cost required to move from a given row in x_n to the same
	%			row in x_nn. Set to inf if state and control results in an
	%			invalid/undefined system transition.
    
	%Convert state variables and inputs to human-readable labels
	st.w = x_n(:,1);
	st.soc = x_n(:,2);
	ctrl.tau_ice = u_n(:,1);
	ctrl.tau_gen = u_n(:,2);
	
	%Calculate the exact solution to the model dynamics
	
	%As the shaft speed is essentially modeled as dw/dt = c this simply
	%gives w_n+1 = w_n + T_s * c.
	
	%Determine the shaft speed derivative
	dwdt = 1/consts.shaft_i * calc_tau_net(ctrl.tau_ice, ctrl.tau_gen, st.w, consts);
	
	%Calculate the shaft speed at the next sample
	st_nn.w = st.w + consts.T_s * dwdt;
	
	%The change in SOC is somewhat more complex to solve. The following
	%anonymous function was generated by the 'gen_battmodel.m' function.
	%Function generated by gen_battmodel.m. DO NOT MODIFY HERE!
	%#!KEYSTR_BATTMODEL_c202543ea4a23969c864d7692a381a3d
delta_soc_f = @(w_0,dwdt,t,tau_gen,p_tot,k_lb,k_lg,batt_energy)-(t.*(p_tot+tau_gen.*w_0+k_lg.*tau_gen.^2+k_lb.*(p_tot+tau_gen.*w_0+k_lg.*tau_gen.^2).^2))./batt_energy-(t.^2.*(dwdt.*tau_gen+dwdt.*k_lb.*tau_gen.*(p_tot+tau_gen.*w_0+k_lg.*tau_gen.^2).*2.0).*(1.0./2.0))./batt_energy-(dwdt.^2.*k_lb.*t.^3.*tau_gen.^2.*(1.0./3.0))./batt_energy;

	%Determine the change in SOC
	delta_soc = delta_soc_f(st.w, dwdt, consts.T_s, ctrl.tau_gen, consts.tot_p_f(t), consts.batt_quadloss, consts.gen_quadloss, consts.batt_energy);
	
	%Update the SOC at the next sample
	st_nn.soc = st.soc + delta_soc;

	%Calculate the cost of the state/control combination.
	
	%As the shaft is a pure integrator, we know that the instantaneous
	%shaft speed is st.w + t*dwdt, where t=0 at the start of the sample and
	%t=T_s at the end of the sample. This can then be used to determine the
	%total fuel consumption by integrating fuelinst(st.w + t*dwdt, tau)
	%from t = 0 to t = T_s
	%At this point, the cost is actually the mass of the fuel
	%consumed per sample.
	
	%Function generated by gen_bsfc_funs.m. Do not modify here!
	%#!KEYSTR_FUELINST_fa8cce87b9df91aa087e5da136558638
fuelinst_f = @(tau,w)abs(tau.*w).*(sqrt(abs(tau-5.0e1).^2.*3.741444191567112e32+abs(w-1.2e2).^2.*5.986310706507379e31).*2.584939414228211e-26+5.555555555555555e-8);
	
	dummy_t = @(t) fuelinst_f(ctrl.tau_ice, st.w + t .* dwdt);
	
	c = zeros(size(st.w));
	
	for k = 0:consts.N_int-1
		c = c + consts.T_s/consts.N_int * dummy_t(k * consts.T_s/consts.N_int + 1/2 * consts.T_s/consts.N_int);
	end
	
	%Add a penalty term that penalizes nonzero control signals. Set the
	%penalty to be so small as to have absolutely no effect on costs where
	%actual fuel is consumed. Add the penalty term if any control is
	%nonzero.
	nonzero_idx = (ctrl.tau_ice ~= 0) & (ctrl.tau_gen ~= 0);
	c(nonzero_idx) = c(nonzero_idx) + realmin;
	
	%Add a finite, but extremely large, penalty if the shaft speed is
	%negative
	c(st.w < 0) = c(st.w < 0) + consts.dp_inp.sol.pen_fun_a(0);
	
	c(~isfinite(c)) = inf;
	
	x_nn = [st_nn.w, st_nn.soc];
	
end
